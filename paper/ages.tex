\section{Kinematic ages}
\subsection{Calculating velocity dispersions}
\label{sec:velocity_dispersion}

A kinematic age can be calculated from the velocity dispersion, \ie\ standard
deviation, of a group of stars.
These velocity dispersions can then be converted into an age using an AVR
\citep[\eg][]{holmberg2009, yu2018}.
Kinematic ages represent the {\it average age} of a group of stars and are
most informative when stars are grouped by age.
If a group of stars have similar ages, their kinematic age will be close
the age of each individual.
On the other hand, the kinematic age of a group with large age variance will
not provide much information about the ages of individual stars.
Velocity distributions themselves do not reveal whether a group of stars have
similar or different ages, since either case the velocities are
Gaussian-distributed.
Fortunately however, we can group \kepler\ stars by age using the implicit
assumption that underpins gyrochronology: that stars with the same rotation
period and color are the same age.
% We discuss the implications of this assumption and cases where it doesn't
% apply in the Discussion of this paper (section \ref{sec:discussion}).

In this paper, we calculated the kinematic age of {\it each individual star}
in our sample, by grouping it with its neighbors in \logp--\teff\ space.
This method is similar to calculating a rolling, or running standard
deviation and allowed us to assign a unique age to each star.
However, ages calculated this way are tightly correlated, and their
correlation depends strongly on bin-size.
In \citet{lu2021} we optimized the bin-size for calculating kinematic ages
using a set of asteroseismic stars.
We use the kinematic ages calculated in that work here.

% To calculate a \vz\ velocity dispersion and kinematic age for each \kepler\
% rotator, we grouped stars with their neighbors in \logp--\teff\ space.
% We tested two methods of grouping stars: K-nearest neighbors, and bins in
% \logp\ and \teff .
% In the K-nearest neighbors method, each star was grouped with the K-nearest
% stars in \logp-\teff\ space.
% Groups created this way spanned a small \logp -\teff\ range where the stellar
% number density was large, and a large range where the number density was
% small.
% In other words, the number of stars was fixed but the window-size changed.
% In the fixed range method, stars were grouped within a fixed \logp -\teff
% window.
% This method created groups with large numbers of stars in densely populated
% regions of the \logp--\teff\ plane, and small numbers of stars in sparsely
% populated regions, \ie\ the number of stars changed but the window-size was
% fixed.
% To choose the best method, and to optimize for the parameters of each (K and
% window-size), we conducted a set of tests.

\subsection{Converting velocity dispersion to age with an AVR}
\label{sec:avr}
We used the \citet{yu2018} AVR to convert velocity dispersion to age.
This relation was calibrated using the ages and velocities of red clump stars.
They divided their sample into metal rich and poor subsets, and calibrated
separate AVRs for each, plus a global AVR.
Their AVR is a power law:
\begin{equation}
    \sigma_{vz} = \alpha t ^\beta,
\end{equation}
where $\alpha$ and $\beta$ take values (6.38, 0.578) for metal rich stars
(3.89, 1.01) for metal poor stars, and (5.47, 0.765) for all stars.

We used 1.5$\times$ the Median Absolute Deviation (MAD) of velocities, which
is a robust approximation to the standard deviation and is less sensitive to
outliers.
Velocity outliers could be binary stars or could be generated by
underestimated parallax or proper motion uncertainties.
